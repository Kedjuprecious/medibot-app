// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message.sql

package repo

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversation (user_id)
VALUES ($1)
RETURNING id
`

func (q *Queries) CreateConversation(ctx context.Context, userID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createConversation, userID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createMessage = `-- name: CreateMessage :exec
INSERT INTO messages (con_id,sender,content)
VALUES($1,$2,$3)
`

type CreateMessageParams struct {
	ConID   uuid.UUID `json:"con_id"`
	Sender  string    `json:"sender"`
	Content string    `json:"content"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) error {
	_, err := q.db.Exec(ctx, createMessage, arg.ConID, arg.Sender, arg.Content)
	return err
}

const createSummaries = `-- name: CreateSummaries :exec
INSERT INTO summaries (content,conversation_id,patient_id,doctor_id)
VALUES ($1,$2,$3,$4)
`

type CreateSummariesParams struct {
	Content        string    `json:"content"`
	ConversationID uuid.UUID `json:"conversation_id"`
	PatientID      uuid.UUID `json:"patient_id"`
	DoctorID       uuid.UUID `json:"doctor_id"`
}

func (q *Queries) CreateSummaries(ctx context.Context, arg CreateSummariesParams) error {
	_, err := q.db.Exec(ctx, createSummaries,
		arg.Content,
		arg.ConversationID,
		arg.PatientID,
		arg.DoctorID,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (email,username,role,experience,location,license_number)
VALUES ($1,$2,$3,$4,$5,$6)
`

type CreateUserParams struct {
	Email         string `json:"email"`
	Username      string `json:"username"`
	Role          string `json:"role"`
	Experience    string `json:"experience"`
	Location      string `json:"location"`
	LicenseNumber string `json:"license_number"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.Email,
		arg.Username,
		arg.Role,
		arg.Experience,
		arg.Location,
		arg.LicenseNumber,
	)
	return err
}

const getConMessages = `-- name: GetConMessages :many
SELECT m.id, m.con_id, m.sender, m.content, m.timestamp FROM conversation c
JOIN messages m 
ON c.id = m.con_id
WHERE c.id = $1
`

func (q *Queries) GetConMessages(ctx context.Context, id uuid.UUID) ([]Message, error) {
	rows, err := q.db.Query(ctx, getConMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConID,
			&i.Sender,
			&i.Content,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversation = `-- name: GetConversation :one
SELECT id, user_id, created_at FROM conversation
WHERE id = $1 AND user_id = $2
`

type GetConversationParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetConversation(ctx context.Context, arg GetConversationParams) (Conversation, error) {
	row := q.db.QueryRow(ctx, getConversation, arg.ID, arg.UserID)
	var i Conversation
	err := row.Scan(&i.ID, &i.UserID, &i.CreatedAt)
	return i, err
}

const getSummary = `-- name: GetSummary :one
SELECT id, content, conversation_id, patient_id, doctor_id, created_at FROM summaries WHERE id = $1
`

func (q *Queries) GetSummary(ctx context.Context, id uuid.UUID) (Summary, error) {
	row := q.db.QueryRow(ctx, getSummary, id)
	var i Summary
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.ConversationID,
		&i.PatientID,
		&i.DoctorID,
		&i.CreatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, username, role, experience, location, license_number, created_at FROM users 
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Role,
		&i.Experience,
		&i.Location,
		&i.LicenseNumber,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, role, experience, location, license_number, created_at FROM users 
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Role,
		&i.Experience,
		&i.Location,
		&i.LicenseNumber,
		&i.CreatedAt,
	)
	return i, err
}

const listFullConversationsByUserID = `-- name: ListFullConversationsByUserID :many
SELECT
    c.id AS conversation_id,
    c.created_at AS conversation_created_at,
    m.id AS message_id,
    m.sender AS message_sender,
    m.content AS message_content,
    m.timestamp AS message_timestamp
FROM
    conversation c
LEFT JOIN
    messages m ON c.id = m.con_id
WHERE
    c.user_id = $1
ORDER BY
    c.created_at DESC, m.timestamp ASC
`

type ListFullConversationsByUserIDRow struct {
	ConversationID        uuid.UUID        `json:"conversation_id"`
	ConversationCreatedAt pgtype.Timestamp `json:"conversation_created_at"`
	MessageID             uuid.UUID        `json:"message_id"`
	MessageSender         string           `json:"message_sender"`
	MessageContent        string           `json:"message_content"`
	MessageTimestamp      pgtype.Timestamp `json:"message_timestamp"`
}

func (q *Queries) ListFullConversationsByUserID(ctx context.Context, userID uuid.UUID) ([]ListFullConversationsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listFullConversationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFullConversationsByUserIDRow{}
	for rows.Next() {
		var i ListFullConversationsByUserIDRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.ConversationCreatedAt,
			&i.MessageID,
			&i.MessageSender,
			&i.MessageContent,
			&i.MessageTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
